Trong file App.jsx - frontend
import React, {useState, useEffect} from 'react';
import './App.css';
import {useFormik} from 'formik';
import axios from 'axios';
import Receiver from './Receiver.jsx';
import {toast, ToastContainer} from 'react-toastify';
import {KJUR, KEYUTIL, hextob64u} from 'jsrsasign';
import GenerateKeyPair from "./GenerateKeyPair.jsx";

function App() {
    const [keyPair, setKeyPair] = useState(null); // State ƒë·ªÉ l∆∞u tr·ªØ keypair

    const formData = useFormik({
        initialValues: {
            ip: '',
            file: null,
            publicKeyPem: '',
            signature: '',
        },
        onSubmit: async (values, {setSubmitting}) => {
            try {
                //get key pair
                const keyPair = await GenerateKeyPair();
                console.log(keyPair.publicKey)

                //exporting public key to .pem file
                let publicKeyPem = null;
                try {
                    publicKeyPem = KEYUTIL.getPEM(keyPair.publicKey);
                } catch (e) {
                    console.log(e.message)
                }

                // reading file that will be sent
                const fileBuffer = await values.file.arrayBuffer();
                const binaryStr = String.fromCharCode(...new Uint8Array(fileBuffer));

                // creating sha256 hash and signing
                const sha256 = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});
                sha256.updateString(binaryStr);
                const hash = sha256.digest();

                const sig = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
                sig.init(KEYUTIL.getKey(KEYUTIL.getPEM(keyPair.privateKey, "PKCS1PRV")), "privateKey");
                sig.updateHex(hash);
                const signature = sig.sign();

                // update formData content
                const form = new FormData();
                form.append('ip', values.ip);
                form.append('file', values.file);
                form.append('publicKeyPem', publicKeyPem);
                form.append('signature', signature);

                const response = await axios.post('http://192.168.1.23:3000/upload', form, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
                toast.success(response.data.message || '‚úÖ Upload th√†nh c√¥ng');
            } catch (e) {
                console.log('ERROR: ', e.message)
            }
        }
    });

    return (
        <div className={'h-screen w-screen'}>
            <Receiver/>
            <div className={'h-full w-full flex flex-row justify-center items-center'}>
                <form onSubmit={formData.handleSubmit} className={'shadow-md shadow-gray-500 rounded-md'}>
                    {/* ... (ph·∫ßn form gi·ªØ nguy√™n) */}
                    <div className={'bg-emerald-600 p-2 flex flex-row justify-center items-center'}>Form g·ª≠i file</div>

                    <div className={'p-2'}>
                        <fieldset className={'border-2 border-gray-500'}>
                            <legend>Nh·∫≠p ƒë·ªãa ch·ªâ IP ng∆∞·ªùi g·ª≠i:</legend>
                            <input type='text'
                                   name={'ip'} placeholder={`IP address... `} value={formData.values.ip}
                                   onChange={formData.handleChange} className={'w-full p-1 outline-emerald-600'}/>
                        </fieldset>
                        <fieldset className={'border-2 border-gray-500'}>

                            <legend>File media mu·ªën g·ª≠i ƒëi:</legend>
                            <input type='file' name={'file'} placeholder={`File upload... `}
                                   onChange={(event) => {
                                       formData.setFieldValue('file', event.currentTarget.files[0]);
                                   }} className={'w-full p-1 outline-emerald-600'}/>
                        </fieldset>
                        <div className={'w-full h-full mt-2 flex flex-row justify-around items-center'}>
                            <button type='submit' className={'border-1 border-emerald-600 rounded-full px-2 py-1'}>
                                G·ª≠i
                            </button>
                            <button type='button' className={'border-1 border-emerald-600 rounded-full px-2 py-1'}>
                                H·ªßy
                            </button>
                        </div>
                    </div>

                </form>
            </div>
            <ToastContainer/>
        </div>
    );
}

export default App;

Trong file index.js -backend:
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const morgan = require('morgan');
const cors = require('cors');
const { WebSocketServer } = require('ws');
const { networkInterfaces } = require("os");
const forge = require('node-forge'); // ‚úÖ Th√™m d√≤ng n√†y
require('dotenv').config();

const app = express();
app.use(cors({ origin: '*' }));
app.set('trust proxy', true);

const PORT = 3000;

// ‚ùå Kh√¥ng d√πng HTTPS n·ªØa
const http = require('http');
const httpServer = http.createServer(app);

// ‚úÖ T·∫°o WebSocket Server tr√™n HTTP
const wss = new WebSocketServer({ server: httpServer, clientTracking: true });

let ipToSocket = new Map();

wss.on('connection', (ws, req) => {
    const clientIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
    console.log(`IP c·ªßa client k·∫øt n·ªëi: ${clientIp}`);

    ws.on('message', (message) => {
        const msg = JSON.parse(message);
        if (msg.type === 'register') {
            ipToSocket.set(clientIp, ws);
            console.log(`üü¢ ƒê√£ ƒëƒÉng k√Ω m√°y nh·∫≠n v·ªõi IP: ${clientIp}`);
        }
    });

    ws.on('close', () => {
        for (const [ip, socket] of ipToSocket.entries()) {
            if (socket === ws) ipToSocket.delete(ip);
        }
    });
});

// Th∆∞ m·ª•c l∆∞u file upload
const uploadDir = path.join(__dirname, '../uploads');
if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
}

// C·∫•u h√¨nh Multer ƒë·ªÉ l∆∞u file
const storage = multer.diskStorage({
    destination: (req, file, cb) => cb(null, uploadDir),
    filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname)
});
const upload = multer({ storage });

app.use(morgan('dev'));

app.post('/upload', upload.single('file'), (req, res) => {
    if (!req.file) {
        return res.status(400).json({ success: false, message: 'Kh√¥ng c√≥ file ƒë∆∞·ª£c g·ª≠i' });
    }

    console.log(req.body);

    const { ip } = req.body;
    const file = req.file;
    const publicKeyPem = req.body.publicKeyPem;
    const signatureBase64 = req.body.signature;

    const logData = {
        ip: ip || req.ip,
        filename: file.originalname,
        savedAs: file.filename,
        uploadedAt: new Date().toISOString(),
    };
    fs.appendFileSync('./logs/upload.log', JSON.stringify(logData) + '\n');

    const fileBuffer = fs.readFileSync(req.file.path);
    const signatureBytes = forge.util.decode64(signatureBase64);

    // ‚úÖ T·∫°o hash SHA-256
    const md = forge.md.sha256.create();
    md.update(fileBuffer.toString('binary'), 'binary');

    let isVerified = false;
    try {
        const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
        console.log('md:',md.digest().bytes());
        console.log(signatureBytes);
        isVerified = publicKey.verify(md.digest().bytes(), signatureBytes);
    } catch (e) {
        console.error('‚ùå L·ªói x√°c minh ch·ªØ k√Ω:', e);
    }

    if (isVerified) {
        const targetWS = ipToSocket.get(ip);
        if (targetWS && targetWS.readyState === 1) {
            targetWS.send(JSON.stringify({
                type: 'file',
                filename: file.originalname,
                fileContent: fileBuffer.toString('base64'),
                signature: signatureBase64,
                publicKey: publicKeyPem
            }));
            return res.json({ success: true, message: '‚úÖ ƒê√£ g·ª≠i file ƒë·∫øn m√°y nh·∫≠n qua WebSocket' });
        } else {
            return res.status(404).json({ success: false, message: '‚ùå Kh√¥ng t√¨m th·∫•y m√°y nh·∫≠n (IP ch∆∞a ƒëƒÉng k√Ω)' });
        }
    } else {
        return res.status(400).json({ success: false, message: '‚ùå Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá' });
    }
});

// ‚úÖ Kh·ªüi ƒë·ªông HTTP Server
httpServer.listen(PORT, '0.0.0.0', () => {
    const interfaces = networkInterfaces();
    Object.keys(interfaces).forEach((ifaceName) => {
        interfaces[ifaceName].forEach((iface) => {
            if (iface.family === 'IPv4' && !iface.internal) {
                console.log(`üöÄ Server ƒëang ch·∫°y t·∫°i: http://${iface.address}:${PORT}`);
            }
        });
    });
});
