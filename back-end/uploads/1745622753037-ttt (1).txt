Trong file App.jsx:
import React, { useState } from 'react';
import './App.css';
import { useFormik } from 'formik';
import axios from 'axios';
import Receiver from './Receiver.jsx';
import { toast, ToastContainer } from 'react-toastify';
import generateKeyPair from "./GenerateKeyPair.jsx";
import forge from 'node-forge'

function App() {
    const formData = useFormik({
        initialValues: {
            ip: '',
            file: null,
            publicKeyPem:null,
            signature: '',
        },
        onSubmit: async (values, { setSubmitting }) => {
            try {
                // ‚úÖ T·∫°o keypair RSA b·∫±ng forge
                const keypair = await generateKeyPair();
                console.log('keyPair:', keypair); // üëà th√™m d√≤ng n√†y ƒë·ªÉ ki·ªÉm tra

                // ‚úÖ Xu·∫•t public key sang PEM
                const publicKeyPem = forge.pki.publicKeyToPem(keypair.publicKey);

                // ‚úÖ ƒê·ªçc n·ªôi dung file
                const fileBuffer = await values.file.arrayBuffer();
                const binaryStr = String.fromCharCode(...new Uint8Array(fileBuffer));

                // ‚úÖ T·∫°o hash SHA-256 v√† k√Ω
                const md = forge.md.sha256.create();
                md.update(binaryStr, 'binary');
                const signatureBytes = keypair.privateKey.sign(md);
                const signatureBase64 = forge.util.encode64(signatureBytes);

                // ‚úÖ T·∫°o form data ƒë·ªÉ upload
                const form = new FormData();
                form.append('ip', values.ip);
                form.append('file', values.file);
                form.append('publicKeyPem', publicKeyPem);
                form.append('signature', signatureBase64);

                const response = await axios.post('http://192.168.1.23:3000/upload', form, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });

                toast.success(response.data.message || '‚úÖ Upload th√†nh c√¥ng');
            } catch (err) {
                console.error('Upload error:', err.message);
                toast.error('‚ùå L·ªói upload');
            } finally {
                setSubmitting(false);
            }
        }
    });

    return (
        <div className={'h-screen w-screen'}>
            <Receiver />
            <div className={'h-full w-full flex flex-row justify-center items-center'}>
                <form onSubmit={formData.handleSubmit} className={'shadow-md shadow-gray-500 rounded-md'}>
                    <div className={'bg-emerald-600 p-2 flex flex-row justify-center items-center'}>Form g·ª≠i file</div>
                    <div className={'p-2'}>
                        <fieldset className={'border-2 border-gray-500'}>
                            <legend>Nh·∫≠p ƒë·ªãa ch·ªâ IP ng∆∞·ªùi g·ª≠i:</legend>
                            <input type='text' name={'ip'} placeholder={`IP address... `} value={formData.values.ip}
                                   onChange={formData.handleChange} className={'w-full p-1 outline-emerald-600'} />
                        </fieldset>
                        <fieldset className={'border-2 border-gray-500'}>
                            <legend>File media mu·ªën g·ª≠i ƒëi:</legend>
                            <input type='file' name={'file'} placeholder={`File upload... `}
                                   onChange={(event) => {
                                       formData.setFieldValue('file', event.currentTarget.files[0]);
                                   }} className={'w-full p-1 outline-emerald-600'} />
                        </fieldset>
                        <div className={'w-full h-full mt-2 flex flex-row justify-around items-center'}>
                            <button type='submit' className={'border-1 border-emerald-600 rounded-full px-2 py-1'}>
                                G·ª≠i
                            </button>
                            <button type='button' className={'border-1 border-emerald-600 rounded-full px-2 py-1'}>
                                H·ªßy
                            </button>
                        </div>
                    </div>
                </form>
            </div>
            <ToastContainer />
        </div>
    );
}

export default App;


Trong file GenerateKeyPair.jsx:
import forge from 'node-forge';

// H√†m t·∫°o c·∫∑p kh√≥a RSA s·ª≠ d·ª•ng Web Worker
const GenerateKeyPair = async () => {
    return new Promise((resolve, reject) => {
        // G·ª≠i y√™u c·∫ßu ƒë·∫øn worker
        forge.prime.worker.postMessage({ type: 'generateKeyPair' });

        // X·ª≠ l√Ω k·∫øt qu·∫£ tr·∫£ v·ªÅ t·ª´ worker
        forge.prime.worker.onmessage = function(event) {
            const data = event.data;
            if (data.error) {
                reject(data.error);
            } else {
                resolve(data); // tr·∫£ v·ªÅ keypair
            }
        };

        // N·∫øu c√≥ l·ªói trong vi·ªác g·ª≠i th√¥ng ƒëi·ªáp ƒë·∫øn worker
        forge.prime.worker.onerror = function(error) {
            reject(error.message);
        };
    });
};

export default GenerateKeyPair;

Trong file Receiver.jsx:
import React, { useEffect, useRef, useState } from 'react';
import { ToastContainer } from "react-toastify";
import forge from 'node-forge';

export default function Receiver() {
    const [message, setMessage] = useState('üü¢ ƒêang ch·ªù file...');
    const ws = useRef(null);

    const verifySignature = async (fileContentBase64, signatureBase64, publicKeyPem) => {
        try {
            const fileBytes = forge.util.decode64(fileContentBase64);
            const signatureBytes = forge.util.decode64(signatureBase64);
            const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);

            const md = forge.md.sha256.create();
            md.update(fileBytes, 'raw');

            const isValid = publicKey.verify(md.digest().bytes(), signatureBytes);
            return isValid;
        } catch (err) {
            console.error("‚ùå L·ªói khi x√°c minh ch·ªØ k√Ω:", err);
            return false;
        }
    };

    useEffect(() => {
        let socket;

        const connectWebSocket = async () => {
            try {
                socket = new WebSocket('ws://192.168.1.23:3000'); // ƒë·ªïi sang ws:// n·∫øu ch·∫°y b·∫±ng HTTP
                ws.current = socket;

                socket.onerror = (e) => {
                    console.error('WebSocket error:', e);
                };

                socket.onopen = () => {
                    console.log("üîå K·∫øt n·ªëi WebSocket m·ªü");
                    socket.send(JSON.stringify({
                        type: 'register',
                    }));
                };

                socket.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'file') {
                        setMessage(`üì¶ ƒêang x√°c minh file: ${data.filename}...`);

                        const isValid = await verifySignature(data.fileContent, data.signature, data.publicKey);

                        if (isValid) {
                            setMessage(`‚úÖ ƒê√£ x√°c minh th√†nh c√¥ng file: ${data.filename}`);

                            // üß† Gi·∫£i m√£ base64 th√†nh blob
                            const byteCharacters = atob(data.fileContent);
                            const byteNumbers = Array.from(byteCharacters).map(char => char.charCodeAt(0));
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray]);

                            // üíæ T·∫°o ƒë∆∞·ªùng d·∫´n t·∫£i xu·ªëng
                            const downloadUrl = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = downloadUrl;
                            a.download = data.filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(downloadUrl);
                        } else {
                            setMessage(`‚ùå Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá cho file: ${data.filename}`);
                        }
                    }
                };

                socket.onclose = () => {
                    console.log("üîå WebSocket ng·∫Øt k·∫øt n·ªëi");
                    setMessage('üî¥ M·∫•t k·∫øt n·ªëi v·ªõi server');
                };
            } catch (e) {
                console.error('Failed to create WebSocket:', e.message);
            }
        };

        connectWebSocket();

        return () => {
            if (ws.current) {
                ws.current.close();
            }
        };
    }, []);

    return (
        <div className="p-4">
            <h1 className="text-xl font-bold">üéß Tr√¨nh nh·∫≠n file qua WebSocket</h1>
            <p className="mt-2">{message}</p>
            <ToastContainer />
        </div>
    );
}


Trong file vite.config.js:
import {defineConfig} from 'vite';
import tailwindcss from '@tailwindcss/vite';
import react from '@vitejs/plugin-react';
import inject from '@rollup/plugin-inject';
import * as fs from "node:fs";
import * as path from "node:path";

export default defineConfig({
    server: {
        host: '0.0.0.0',
        port: 5173,
    },
    plugins: [
        tailwindcss(),
        react(),
        inject({
            Buffer: ['buffer', 'Buffer'],
            process: 'process',
        }),
    ],
    resolve: {
        alias: {
            stream: 'stream-browserify',
            buffer: 'buffer/',
            process: 'process/browser',
        },
    },
    worker: {
        format: 'es'
    }
});

