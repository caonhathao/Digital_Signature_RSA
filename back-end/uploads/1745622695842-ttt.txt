Trong App.jsx ·ªü front-end:
import React, {useState, useEffect} from 'react';
import './App.css';
import {useFormik} from 'formik';
import axios from 'axios';
import Receiver from './Receiver.jsx';
import {toast, ToastContainer} from 'react-toastify';
import {KJUR, KEYUTIL, hextob64u} from 'jsrsasign';
import GenerateKeyPair from "./GenerateKeyPair.jsx";
import Base64Encode from "./Base64Encode.jsx";

function App() {
    const [keyPair, setKeyPair] = useState(null); // State ƒë·ªÉ l∆∞u tr·ªØ keypair

    const formData = useFormik({
        initialValues: {
            ip: '',
            file: null,
            publicKeyPem: '',
            signature: '',            fileContentBase64: '' // Th√™m tr∆∞·ªùng n√†y

        },
        onSubmit: async (values, {setSubmitting}) => {
            try {
                //get key pair
                const keyPair = await GenerateKeyPair();
                console.log(keyPair.publicKey)

                //exporting public key to .pem file
                let publicKeyPem = null;
                try {
                    publicKeyPem = KEYUTIL.getPEM(keyPair.publicKey);
                } catch (e) {
                    console.log(e.message)
                }

                // reading file that will be sent
                const fileBuffer = await values.file.arrayBuffer();
                const binaryStr = Base64Encode(fileBuffer);

                // creating sha256 hash and signing
                const sha256 = new KJUR.crypto.MessageDigest({alg: "sha256", prov: "cryptojs"});
                sha256.updateString(binaryStr);
                const hash = sha256.digest();

                const sig = new KJUR.crypto.Signature({alg: "SHA256withRSA", prov: "cryptojs/jsrsa"});
                sig.init(KEYUTIL.getKey(KEYUTIL.getPEM(keyPair.privateKey, "PKCS1PRV")), "privateKey");
                sig.updateHex(hash);
                const signature = sig.sign();

                // update formData content
                const form = new FormData();
                form.append('ip', values.ip);
                form.append('file', values.file);
                form.append('publicKeyPem', publicKeyPem);
                form.append('signature', signature);
                form.append('fileContentBase64', binaryStr);

                const response = await axios.post('http://192.168.1.23:3000/upload', form, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
                toast.success(response.data.message || '‚úÖ Upload th√†nh c√¥ng');
            } catch (e) {
                console.log('ERROR: ', e.message)
            }
        }
    });

    return (
        <div className={'h-screen w-screen'}>
            <Receiver/>
            <div className={'h-full w-full flex flex-row justify-center items-center'}>
                <form onSubmit={formData.handleSubmit} className={'shadow-md shadow-gray-500 rounded-md'}>
                    {/* ... (ph·∫ßn form gi·ªØ nguy√™n) */}
                    <div className={'bg-emerald-600 p-2 flex flex-row justify-center items-center'}>Form g·ª≠i file</div>

                    <div className={'p-2'}>
                        <fieldset className={'border-2 border-gray-500'}>
                            <legend>Nh·∫≠p ƒë·ªãa ch·ªâ IP ng∆∞·ªùi g·ª≠i:</legend>
                            <input type='text'
                                   name={'ip'} placeholder={`IP address... `} value={formData.values.ip}
                                   onChange={formData.handleChange} className={'w-full p-1 outline-emerald-600'}/>
                        </fieldset>
                        <fieldset className={'border-2 border-gray-500'}>

                            <legend>File media mu·ªën g·ª≠i ƒëi:</legend>
                            <input type='file' name={'file'} placeholder={`File upload... `}
                                   onChange={(event) => {
                                       formData.setFieldValue('file', event.currentTarget.files[0]);
                                   }} className={'w-full p-1 outline-emerald-600'}/>
                        </fieldset>
                        <div className={'w-full h-full mt-2 flex flex-row justify-around items-center'}>
                            <button type='submit' className={'border-1 border-emerald-600 rounded-full px-2 py-1'}>
                                G·ª≠i
                            </button>
                            <button type='button' className={'border-1 border-emerald-600 rounded-full px-2 py-1'}>
                                H·ªßy
                            </button>
                        </div>
                    </div>

                </form>
            </div>
            <ToastContainer/>
        </div>
    );
}

export default App;

Trong file Receiver.jsx:
import React, { useEffect, useRef, useState } from 'react';
import { ToastContainer } from "react-toastify";
import { KJUR, KEYUTIL, hextob64u } from 'jsrsasign'; // ‚úÖ Import jsrsasign

export default function Receiver() {
    const [message, setMessage] = useState('üü¢ ƒêang ch·ªù file...');
    const ws = useRef(null);

    const verifySignature = async (fileContentBase64, signatureBase64, publicKeyPem) => {
        try {
            const isValid = KJUR.crypto.Signature.verify(
                "SHA256withRSA",
                publicKeyPem,
                fileContentBase64,  // Assuming fileContent is already base64
                signatureBase64
            );
            return isValid;
        } catch (err) {
            console.error("‚ùå L·ªói khi x√°c minh ch·ªØ k√Ω:", err);
            return false;
        }
    };

    useEffect(() => {
        let socket;

        const connectWebSocket = async () => {
            try {
                socket = new WebSocket('ws://192.168.1.23:3000'); // ƒë·ªïi sang ws:// n·∫øu ch·∫°y b·∫±ng HTTP
                ws.current = socket;

                socket.onerror = (e) => {
                    console.error('WebSocket error:', e);
                };

                socket.onopen = () => {
                    console.log("üîå K·∫øt n·ªëi WebSocket m·ªü");
                    socket.send(JSON.stringify({
                        type: 'register',
                    }));
                };

                socket.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'file') {
                        setMessage(`üì¶ ƒêang x√°c minh file: ${data.filename}...`);

                        const isValid = await verifySignature(data.fileContent, data.signature, data.publicKey);

                        if (isValid) {
                            setMessage(`‚úÖ ƒê√£ x√°c minh th√†nh c√¥ng file: ${data.filename}`);
                            // Gi·∫£i m√£ Base64 ƒë·ªÉ t·∫°o Blob
                            const byteCharacters = atob(fileContentBase64);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            const blob = new Blob([byteArray]);

                            // üíæ T·∫°o ƒë∆∞·ªùng d·∫´n t·∫£i xu·ªëng
                            const downloadUrl = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = downloadUrl;
                            a.download = data.filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(downloadUrl);
                        } else {
                            setMessage(`‚ùå Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá cho file: ${data.filename}`);
                        }
                    }
                };
                socket.onclose = () => {
                    console.log("üîå WebSocket ng·∫Øt k·∫øt n·ªëi");
                    setMessage('üî¥ M·∫•t k·∫øt n·ªëi v·ªõi server');
                };
            } catch (e) {
                console.error('Failed to create WebSocket:', e.message);
            }
        };

        connectWebSocket();

        return () => {
            if (ws.current) {
                ws.current.close();
            }
        };
    }, []);

    return (
        <div className="p-4">
            <h1 className="text-xl font-bold">üéß Tr√¨nh nh·∫≠n file qua WebSocket</h1>
            <p className="mt-2">{message}</p>
            <ToastContainer />
        </div>
    );
}

Trong file Base64Encode.jsx:

const Base64Encode = (buffer) => {
    let bin = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        bin += String.fromCharCode(bytes[i]);
    }
    return window.btoa(bin);
}
export default Base64Encode;

Trong file index.js c·ªßa backend:
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const morgan = require('morgan');
const cors = require('cors');
const {WebSocketServer} = require('ws');
const {networkInterfaces} = require("os");
require('dotenv').config();
const {KJUR, KEYUTIL, hextob64u, b64utohex} = require('jsrsasign'); // ‚úÖ Import jsrsasign
const app = express();
app.use(cors({origin: '*'}));
app.set('trust proxy', true);
const PORT = 3000;
const http = require('http');
const httpServer = http.createServer(app);
const wss = new WebSocketServer({server: httpServer, clientTracking: true});
let ipToSocket = new Map();
wss.on('connection', (ws, req) => {
    const clientIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
    console.log(`IP c·ªßa client k·∫øt n·ªëi: ${clientIp}`);
    ws.on('message', (message) => {
        const msg = JSON.parse(message);
        if (msg.type === 'register') {
            ipToSocket.set(clientIp, ws);
            console.log(`üü¢ ƒê√£ ƒëƒÉng k√Ω m√°y nh·∫≠n v·ªõi IP: ${clientIp}`);
        }
    });
    ws.on('close', () => {
        for (const [ip, socket] of ipToSocket.entries()) {
            if (socket === ws) ipToSocket.delete(ip);
        }
    });
});
const uploadDir = path.join(__dirname, '../uploads');
if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, {recursive: true});
}
const storage = multer.diskStorage({
    destination: (req, file, cb) => cb(null, uploadDir),
    filename: (req, file, cb) => cb(null, Date.now() + '-' + file.originalname)
});
const upload = multer({storage});
app.use(morgan('dev'));
app.post('/upload', upload.single('file'), (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({success: false, message: 'Kh√¥ng c√≥ file ƒë∆∞·ª£c g·ª≠i'});
        }
        console.log(req.body);
        const {ip} = req.body;
        const file = req.file;
        const publicKeyPem = req.body.publicKeyPem;
        const signatureBase64 = req.body.signature;
        const fileContentBase64 = req.body.fileContentBase64; // L·∫•y d·ªØ li·ªáu Base64

        const logData = {
            ip: ip || req.ip,
            filename: file.originalname,
            savedAs: file.filename,
            uploadedAt: new Date().toISOString(),
        };

        fs.appendFileSync('./logs/upload.log', JSON.stringify(logData) + '\n');
        const fileBuffer = fs.readFileSync(req.file.path);
// Gi·∫£i m√£ Base64
        const fileContent = Buffer.from(fileContentBase64, 'base64').toString('binary');

        //starting verify content
        let isVerified = false;
        try {
            //get public key from .pem file
            const publicKey = KEYUTIL.getKey(publicKeyPem);

            const verifier = new KJUR.crypto.Signature({"alg": "SHA256withRSA"});
            verifier.init(publicKey);
            verifier.updateString(fileContent); // ‚úÖ Update with binary file content
            isVerified = verifier.verify(signatureBase64);
            console.log(b64utohex(signatureBase64));
            // ‚úÖ Verify with hex signature
        } catch (e) {
            console.error('‚ùå L·ªói x√°c minh ch·ªØ k√Ω:', e);
        }

        if (isVerified) {
            const targetWS = ipToSocket.get(ip);
            if (targetWS && targetWS.readyState === 1) {
                targetWS.send(JSON.stringify({
                    type: 'file',
                    filename: file.originalname,
                    fileContent: fileContentBase64,
                    signature: signatureBase64,
                    publicKey: publicKeyPem,
                }));
                return res.json({success: true, message: '‚úÖ ƒê√£ g·ª≠i file ƒë·∫øn m√°y nh·∫≠n qua WebSocket'});
            } else {
                return res.status(404).json({success: false, message: '‚ùå Kh√¥ng t√¨m th·∫•y m√°y nh·∫≠n (IP ch∆∞a ƒëƒÉng k√Ω)'});
            }
        } else {
            return res.status(400).json({success: false, message: '‚ùå Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá'});
        }
    } catch (e) {
        console.log(e.message)
    }
});
httpServer.listen(PORT, '0.0.0.0', () => {
    const interfaces = networkInterfaces();
    Object.keys(interfaces).forEach((ifaceName) => {
        interfaces[ifaceName].forEach((iface) => {
            if (iface.family === 'IPv4' && !iface.internal) {
                console.log(`üöÄ Server ƒëang ch·∫°y t·∫°i: http://${iface.address}:${PORT}`);
            }
        });
    });
});